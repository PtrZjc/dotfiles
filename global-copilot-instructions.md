# Software Engineering Guidelines

## Core Principles

**KISS (Keep It Simple)**: Prioritize simple, clear solutions. Complexity is the enemy of
maintainability.
**YAGNI (You Aren't Gonna Need It)**: Implement only what's necessary now. Avoid speculative
features.
**SRP (Single Responsibility Principle)**: Design components with a single, well-defined purpose.
This improves clarity, testing, and reuse.
**DRY (Don't Repeat Yourself) & The Rule of Three**: Avoid duplication, but prefer clarity over
premature abstraction. Abstract only when a pattern appears at least three times and a simple,
obvious abstraction emerges.

## Problem-Solving Approach

1. **Understand**: Thoroughly analyze the problem before writing any code
2. **Simplify**: Start with the simplest possible solution that works
3. **Refactor**: Improve the code's structure only when necessary
4. **Log**: Implement meaningful logging for diagnostics and monitoring
5. **Validate**: Consider and handle edge cases and potential errors

## Project Workflow

### Planning First

- All documentation (plans, tasks) resides in the `docs/` directory
- Before coding, check `docs/` for `plan.md` and `tasks.md`
- If they don't exist, create a detailed `docs/plan.md` guided by core principles
- From the plan, generate an enumerated task list in `docs/tasks.md` with `[ ]` checkboxes

### User Approval

After creating the plan and tasks, request user review and approval before proceeding.

### Implementation

- Execute tasks sequentially from `docs/tasks.md`, marking completed tasks with `[x]`
- Before adding code, check if similar functionality already exists
- Replace any deprecated APIs with their modern alternatives
- When running Gradle tests, always use the `--info` flag (`./gradlew test --info`)

### Iterative Validation

After completing a logical group of tasks, ask for user validation before starting the next group.

## Java Development Guidelines

### Data Structures: Records vs. Classes

**Records for Data**: Use Java records as the default choice for immutable data carriers like DTOs,
Value Objects, and API models.

**Classes for Behavior**: Use standard classes for components that encapsulate business logic,
services, and stateful behavior.

**Smart Construction**: Enhance both record and class types with Lombok's `@Builder` when
construction is complex. For classes with behavior, use `@RequiredArgsConstructor` for dependency
injection.

**Utilize Lombok Annotations**: Use Lombok annotations to reduce boilerplate code. Always use them
for constructors and getters. There should be no need to use `@Data` or `@Value` annotations for
records, as they are inherently immutable and concise.

### Code Style

- **Immutability First**: Default to immutable objects and data structures
- **Functional Style**: Prefer streams, collectors, and lambda expressions over traditional loops
- **Restrictive Visibility**: Use the most restrictive access modifier possible
- **Modern Collections**: Use `List.of()`, `Set.of()`, and `Map.of()` for unmodifiable collections
- **Optional Usage**: Use `Optional` for return types that might be null, not for method parameters

## Testing Standards

- **Always use AssertJ**: Use AssertJ assertions for all test assertions instead of JUnit's built-in
  assertions
- **Test naming**: Use short, descriptive names following the `shouldXxxx` pattern (e.g.,
  `shouldReturnEmptyWhenListIsNull`)
- **Test structure**: Always structure tests with `// given`, `// when`, `// then` comments. The
  `// given` section can be omitted if no setup is required
- **Parameterized tests**: Use `@ParameterizedTest` where possible to reduce code duplication and
  test multiple scenarios
- **Data sources**: Prefer `@CsvSource` over `@MethodSource` when possible for better readability
  and simpler test data management
- **Readability**: Focus on test readability and clear intent over complex setup or clever
  assertions
- **Single assertion for DTOs**: For data transfer objects (DTOs) or simple value objects, use a
  single `assertThat(result).usingRecursiveComparison().isEqualTo(expected)` to verify state. This
  is efficient and readable.
    - **Caution**: For objects with complex business logic, be cautious with recursive comparison.
      It may be better to write a few explicit assertions (
      `assertThat(result.getStatus()).isEqualTo(expectedStatus)`) to ensure core logic is tested
      directly.
